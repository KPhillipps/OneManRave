#include "Globals.h"
#include "ColorDefinitions.h"



void meteorShower(CRGB color, int size, int decay) {
    for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
        for (int start = LEDS_PER_VIRTUAL_STRIP - 1; start >= -size; start--) {
            processSerialData();
            if (serialDataPending) { return; }

            for (int led = 0; led < size; led++) {
                int index = start + led;
                if (index >= 0 && index < LEDS_PER_VIRTUAL_STRIP) {
                    *virtualLeds[strip][index] = color;
                }
            }
            FastLED.show();
            // Fade all LEDs for a trailing effect
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
                virtualLeds[strip][led]->fadeToBlackBy(decay);
            }
        }
    }
}

void bouncingBallEffect(bool reset = false) {
    static float position[NUM_VIRTUAL_STRIPS];
    static float velocity[NUM_VIRTUAL_STRIPS];
    static bool hasBounced[NUM_VIRTUAL_STRIPS];
    static uint8_t hue[NUM_VIRTUAL_STRIPS];
    static uint8_t trailBuffer[NUM_VIRTUAL_STRIPS][LEDS_PER_VIRTUAL_STRIP];  // Trail brightness
    static float beatFlash = 0.0f;
    const float gravity = -0.08f;   // Slower gravity for more visible motion
    const int topPosition = LEDS_PER_VIRTUAL_STRIP - 1;
    const int ballSize = 5;         // Ball is 5 LEDs wide (2 on each side of center)

    // Reset logic - start at top
    if (reset) {
        for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            int startOffset = (strip * LEDS_PER_VIRTUAL_STRIP) / (NUM_VIRTUAL_STRIPS + 1);
            position[strip] = topPosition - startOffset;
            if (position[strip] < 0) {
                position[strip] = 0;
            }
            velocity[strip] = 0;
            hasBounced[strip] = false;
            hue[strip] = 160 + (strip * (90 / NUM_VIRTUAL_STRIPS));
            // Clear trail buffer
            for (int i = 0; i < LEDS_PER_VIRTUAL_STRIP; i++) {
                trailBuffer[strip][i] = 0;
            }
        }
        beatFlash = 0.0f;
    }

    // Beat detection - add velocity boost on beat
    bool beatHit = false;
    if (beatAmplitude > 0.15f && beatFlash < 0.3f) {
        beatFlash = 1.0f;
        beatHit = true;
    }
    beatFlash *= 0.88f;

    // Trail decay - less decay on beat for longer trails
    uint8_t trailDecay = beatFlash > 0.3f ? 25 : 40;

    // Fade all trail buffers
    for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
        for (int i = 0; i < LEDS_PER_VIRTUAL_STRIP; i++) {
            if (trailBuffer[strip][i] > trailDecay) {
                trailBuffer[strip][i] -= trailDecay;
            } else {
                trailBuffer[strip][i] = 0;
            }
        }
    }

    // Update and draw each strip independently
    for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
        float g = gravity * (1.0f + (0.08f * strip)); // Slightly different speeds
        velocity[strip] += g;
        position[strip] += velocity[strip];

        // Add velocity boost on beat (makes balls bounce higher)
        if (beatHit) {
            // Add upward velocity if ball is moving down or slow
            if (velocity[strip] < 2.0f) {
                velocity[strip] += 1.5f + (random8() / 255.0f);
            }
        }

        // Bounce at bottom
        if (position[strip] <= 0) {
            position[strip] = 0;
            velocity[strip] = -velocity[strip] * 0.9f;
            hasBounced[strip] = true;
        }

        // If the bounce has died out near the bottom, restart at the top
        float speed = velocity[strip] < 0 ? -velocity[strip] : velocity[strip];
        if (hasBounced[strip] && speed < 0.08f && position[strip] <= 1.0f) {
            hasBounced[strip] = false;
            position[strip] = topPosition;
            velocity[strip] = 0;
        }

        // Clamp at top and restart after one full bounce (independent per strip)
        if (position[strip] > topPosition) {
            position[strip] = topPosition;
            velocity[strip] = 0;
            if (hasBounced[strip]) {
                // Always restart at the top
                hasBounced[strip] = false;
                position[strip] = topPosition;
                velocity[strip] = 0;
            }
        }

        int ledPos = (int)position[strip];

        // Add ball position to trail buffer (ball leaves a bright trail)
        for (int offset = -ballSize/2; offset <= ballSize/2; offset++) {
            int idx = ledPos + offset;
            if (idx >= 0 && idx < LEDS_PER_VIRTUAL_STRIP) {
                trailBuffer[strip][idx] = 255;  // Full brightness where ball is
            }
        }

        // Render the strip from trail buffer
        for (int i = 0; i < LEDS_PER_VIRTUAL_STRIP; i++) {
            if (trailBuffer[strip][i] > 0) {
                *virtualLeds[strip][i] = CHSV(hue[strip], 255, trailBuffer[strip][i]);
            } else {
                *virtualLeds[strip][i] = CRGB::Black;
            }
        }

        // Draw the ball brighter on top (5-LED ball with gradient)
        // Bigger ball on beat
        int currentBallSize = beatFlash > 0.3f ? 7 : ballSize;
        for (int offset = -currentBallSize/2; offset <= currentBallSize/2; offset++) {
            int idx = ledPos + offset;
            if (idx >= 0 && idx < LEDS_PER_VIRTUAL_STRIP) {
                // Brighter at center, dimmer at edges
                uint8_t brightness = 255 - (abs(offset) * 30);
                *virtualLeds[strip][idx] = CHSV(hue[strip], 255, brightness);
            }
        }
    }

    // Flash outer strips on beat
    if (beatFlash > 0.5f) {
        uint8_t flashVal = (uint8_t)(beatFlash * 255);
        for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
            *virtualLeds[0][led] = CHSV(0, 0, flashVal);
            *virtualLeds[NUM_VIRTUAL_STRIPS - 1][led] = CHSV(0, 0, flashVal);
        }
    }

    FastLED.show();
    delay(beatFlash > 0.3f ? 25 : 35);  // Faster on beat
}





void runPattern() {
  static int lastPattern = -1;
  if (state.pattern != lastPattern) {
    DBG_SERIAL_PRINTF("Running pattern %d\n", state.pattern);
    lastPattern = state.pattern;
  }
  switch (state.pattern) {
    case 0:
      break;

    case 1:
      break;

    case 2:
      {                          // Rainbow Pattern with Beat
        static uint8_t hue = 0;  // Global hue, incremented over time
        static float beatFlash = 0.0f;
        uint8_t deltaHue = 7;    // Default spacing for rainbow effect

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;  // Exit loop on state change
          }

          // Beat detection - flash and speed up on beat
          if (beatAmplitude > 0.15f) {
            beatFlash = 1.0f;
          }
          beatFlash *= 0.85f;  // Decay

          // Calculate brightness boost from beat
          uint8_t baseBrightness = 180;
          uint8_t beatBoost = (uint8_t)(beatFlash * 75);
          uint8_t brightness = baseBrightness + beatBoost;

          // Fill virtualLeds with a rainbow pattern
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[strip][led] = CHSV(hue + (strip * LEDS_PER_VIRTUAL_STRIP + led) * deltaHue, 255, brightness);
            }
          }

          // Flash outer strips white on strong beats
          if (beatFlash > 0.5f) {
            uint8_t flashVal = (uint8_t)(beatFlash * 255);
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[0][led] = CHSV(0, 0, flashVal);
              *virtualLeds[NUM_VIRTUAL_STRIPS - 1][led] = CHSV(0, 0, flashVal);
            }
          }

          FastLED.show();
          // Speed up animation on beat
          int frameDelay = beatFlash > 0.3f ? 10 : 20;
          delay(frameDelay);
          hue += beatFlash > 0.3f ? 3 : 1;  // Faster hue shift on beat
        }
      }
      break;

    case 3:
      {  // Rainbow with Sparkle + Beat
        static uint8_t hue = 0;
        static float beatFlash = 0.0f;
        uint8_t deltaHue = 7;

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;
          }

          // Beat detection
          if (beatAmplitude > 0.15f) {
            beatFlash = 1.0f;
          }
          beatFlash *= 0.88f;

          // More sparkles on beat (base 50, up to 255 on beat)
          uint8_t sparkleChance = 50 + (uint8_t)(beatFlash * 205);
          uint8_t brightness = 180 + (uint8_t)(beatFlash * 75);

          // Fill virtualLeds with a rainbow pattern
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[strip][led] = CHSV(hue + (strip * LEDS_PER_VIRTUAL_STRIP + led) * deltaHue, 255, brightness);
            }
          }

          // Add sparkles - more on beat
          int numSparkles = beatFlash > 0.5f ? 10 : 2;
          for (int s = 0; s < numSparkles; s++) {
            if (random8() < sparkleChance) {
              int randomStrip = random(NUM_VIRTUAL_STRIPS);
              int randomLed = random(LEDS_PER_VIRTUAL_STRIP);
              *virtualLeds[randomStrip][randomLed] = CRGB::White;
            }
          }

          // Flash outer strips on beat
          if (beatFlash > 0.5f) {
            uint8_t flashVal = (uint8_t)(beatFlash * 255);
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[0][led] = CHSV(0, 0, flashVal);
              *virtualLeds[NUM_VIRTUAL_STRIPS - 1][led] = CHSV(0, 0, flashVal);
            }
          }

          FastLED.show();
          delay(beatFlash > 0.3f ? 10 : 20);
          hue += beatFlash > 0.3f ? 3 : 1;
        }
      }
      break;

    case 4:
      {  // Fire Pattern with Beat
#define COOLING 100
#define SPARKING 180

        static uint8_t heat[NUM_VIRTUAL_STRIPS][LEDS_PER_VIRTUAL_STRIP] = { { 0 } };
        static float beatFlash = 0.0f;

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;
          }

          // Beat detection - flare up on beat
          if (beatAmplitude > 0.15f) {
            beatFlash = 1.0f;
          }
          beatFlash *= 0.90f;

          // More sparking on beat
          uint8_t sparkChance = SPARKING + (uint8_t)(beatFlash * 75);

          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            // Step 1: Cool down the heat (less cooling on beat for bigger flames)
            uint8_t coolAmount = beatFlash > 0.3f ? COOLING / 2 : COOLING;
            for (int y = 0; y < LEDS_PER_VIRTUAL_STRIP; y++) {
              heat[strip][y] = qsub8(heat[strip][y], random8(0, ((coolAmount * 10) / LEDS_PER_VIRTUAL_STRIP) + 2));
            }

            // Step 2: Heat diffuses upward
            for (int y = LEDS_PER_VIRTUAL_STRIP - 1; y >= 2; y--) {
              heat[strip][y] = (heat[strip][y - 1] + heat[strip][y - 2] + heat[strip][y - 2]) / 3;
            }

            // Step 3: Ignite new sparks at the bottom - more on beat
            if (random8() < sparkChance) {
              int y = random8(7);
              uint8_t sparkIntensity = beatFlash > 0.5f ? 255 : random8(160, 255);
              heat[strip][y] = qadd8(heat[strip][y], sparkIntensity);
            }

            // Extra beat sparks on outer strips
            if (beatFlash > 0.5f && (strip == 0 || strip == NUM_VIRTUAL_STRIPS - 1)) {
              for (int i = 0; i < 5; i++) {
                int y = random8(LEDS_PER_VIRTUAL_STRIP / 3);
                heat[strip][y] = qadd8(heat[strip][y], 255);
              }
            }

            // Step 4: Map heat to colors
            for (int y = 0; y < LEDS_PER_VIRTUAL_STRIP; y++) {
              *virtualLeds[strip][y] = HeatColor(heat[strip][y]);
            }
          }

          FastLED.show();
          delay(5);
        }
      }
      break;

    case 5:
      {  // Sinelon Pattern with Beat
        static uint16_t position[NUM_VIRTUAL_STRIPS] = { 0 };
        static uint8_t hue[NUM_VIRTUAL_STRIPS] = { 0 };
        static float beatFlash = 0.0f;

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;  // Exit on Serial1 input
          }

          // Beat detection
          if (beatAmplitude > 0.15f) {
            beatFlash = 1.0f;
          }
          beatFlash *= 0.88f;

          // Clear all LEDs (fade less on beat for longer trails)
          uint8_t fadeAmount = beatFlash > 0.3f ? 30 : 60;
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              virtualLeds[strip][led]->fadeToBlackBy(fadeAmount);
            }
          }

          // Update each strip with the Sinelon effect
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            hue[strip] += beatFlash > 0.3f ? 16 : 8;  // Faster color change on beat
            position[strip] = beatsin16(13 + strip * 2, 0, LEDS_PER_VIRTUAL_STRIP - 1);

            // Highlight the current position on the strip - brighter on beat
            uint8_t brightness = 180 + (uint8_t)(beatFlash * 75);
            *virtualLeds[strip][position[strip]] = CHSV(hue[strip], 255, brightness);

            // Add extra dot on beat
            if (beatFlash > 0.5f) {
              int mirrorPos = LEDS_PER_VIRTUAL_STRIP - 1 - position[strip];
              *virtualLeds[strip][mirrorPos] = CHSV(hue[strip] + 128, 255, (uint8_t)(beatFlash * 200));
            }
          }

          // Flash outer strips on beat
          if (beatFlash > 0.5f) {
            uint8_t flashVal = (uint8_t)(beatFlash * 255);
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[0][led] = CHSV(0, 0, flashVal);
              *virtualLeds[NUM_VIRTUAL_STRIPS - 1][led] = CHSV(0, 0, flashVal);
            }
          }

          FastLED.show();
          delay(beatFlash > 0.3f ? 8 : 15);
        }
      }
      break;


    case 6:
      {  // Enhanced Sinelon Pattern with Beat
        static uint16_t position[NUM_VIRTUAL_STRIPS] = { 0 };
        static uint8_t hue[NUM_VIRTUAL_STRIPS] = { 0 };
        static float beatFlash = 0.0f;

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;
          }

          // Beat detection
          if (beatAmplitude > 0.15f) {
            beatFlash = 1.0f;
          }
          beatFlash *= 0.88f;

          // Longer comet on beat
          int cometLength = beatFlash > 0.3f ? 35 : 20;

          // Clear LEDs
          FastLED.clear();

          // Update each strip
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            hue[strip] += beatFlash > 0.3f ? 16 : 8;
            position[strip] = beatsin16(13 + strip * 2, 0, LEDS_PER_VIRTUAL_STRIP - 1);

            // Create comet - brighter on beat
            uint8_t baseBrightness = 180 + (uint8_t)(beatFlash * 75);
            for (int offset = 0; offset < cometLength; offset++) {
              int trailPosition = (position[strip] - offset + LEDS_PER_VIRTUAL_STRIP) % LEDS_PER_VIRTUAL_STRIP;
              uint8_t brightness = baseBrightness - (offset * (baseBrightness / cometLength));
              *virtualLeds[strip][trailPosition] += CHSV(hue[strip], 255, brightness);
            }

            // Second comet going opposite direction on beat
            if (beatFlash > 0.5f) {
              int mirrorPos = LEDS_PER_VIRTUAL_STRIP - 1 - position[strip];
              for (int offset = 0; offset < cometLength / 2; offset++) {
                int trailPosition = (mirrorPos + offset) % LEDS_PER_VIRTUAL_STRIP;
                uint8_t brightness = (uint8_t)(beatFlash * 200) - (offset * 10);
                if (brightness > 200) brightness = 0;  // Underflow protection
                *virtualLeds[strip][trailPosition] += CHSV(hue[strip] + 128, 255, brightness);
              }
            }
          }

          // Flash outer strips on beat
          if (beatFlash > 0.5f) {
            uint8_t flashVal = (uint8_t)(beatFlash * 255);
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[0][led] = CHSV(0, 0, flashVal);
              *virtualLeds[NUM_VIRTUAL_STRIPS - 1][led] = CHSV(0, 0, flashVal);
            }
          }

          FastLED.show();
          delay(beatFlash > 0.3f ? 8 : 15);
        }
      }
      break;
    case 7:
      {  // Meteor Shower with Beat - non-blocking version
        static int meteorPos[NUM_VIRTUAL_STRIPS];
        static uint8_t meteorHue[NUM_VIRTUAL_STRIPS];
        static bool meteorActive[NUM_VIRTUAL_STRIPS];
        static float beatFlash = 0.0f;
        static bool initialized = false;

        if (!initialized) {
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            meteorPos[strip] = -1;
            meteorActive[strip] = false;
            meteorHue[strip] = random8();
          }
          FastLED.clear();
          initialized = true;
        }

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            initialized = false;  // Reset on exit
            break;
          }

          // Beat detection - trigger meteors on beat
          if (beatAmplitude > 0.15f) {
            beatFlash = 1.0f;
            // Launch meteors on random strips on beat
            int numToLaunch = random8(3, 6);
            for (int i = 0; i < numToLaunch; i++) {
              int strip = random8(NUM_VIRTUAL_STRIPS);
              if (!meteorActive[strip]) {
                meteorActive[strip] = true;
                meteorPos[strip] = LEDS_PER_VIRTUAL_STRIP + 10;  // Start above top
                meteorHue[strip] = random8();
              }
            }
          }
          beatFlash *= 0.90f;

          // Randomly spawn meteors when idle
          if (random8() < 15) {
            int strip = random8(NUM_VIRTUAL_STRIPS);
            if (!meteorActive[strip]) {
              meteorActive[strip] = true;
              meteorPos[strip] = LEDS_PER_VIRTUAL_STRIP + 10;
              meteorHue[strip] = random8();
            }
          }

          // Fade all LEDs
          uint8_t fadeAmount = beatFlash > 0.3f ? 30 : 50;
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              virtualLeds[strip][led]->fadeToBlackBy(fadeAmount);
            }
          }

          // Update and draw meteors
          int meteorSize = beatFlash > 0.3f ? 8 : 5;
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            if (meteorActive[strip]) {
              meteorPos[strip] -= 2;  // Move down

              // Draw meteor with gradient tail
              for (int i = 0; i < meteorSize; i++) {
                int pos = meteorPos[strip] + i;
                if (pos >= 0 && pos < LEDS_PER_VIRTUAL_STRIP) {
                  uint8_t brightness = 255 - (i * (200 / meteorSize));
                  *virtualLeds[strip][pos] = CHSV(meteorHue[strip], 255, brightness);
                }
              }

              // Deactivate when off screen
              if (meteorPos[strip] < -meteorSize) {
                meteorActive[strip] = false;
              }
            }
          }

          // Flash outer strips on beat
          if (beatFlash > 0.5f) {
            uint8_t flashVal = (uint8_t)(beatFlash * 255);
            for (int led = 0; led < LEDS_PER_VIRTUAL_STRIP; led++) {
              *virtualLeds[0][led] = CHSV(0, 0, flashVal);
              *virtualLeds[NUM_VIRTUAL_STRIPS - 1][led] = CHSV(0, 0, flashVal);
            }
          }

          FastLED.show();
          delay(beatFlash > 0.3f ? 15 : 25);
        }
      }
      break;
case 8:
      FastLED.clear();
      FastLED.show();
    // Reset the ball's position and velocity before starting
    bouncingBallEffect(true); // Pass `true` to reset

    for (;;) { // Infinite loop to keep the effect running
        processSerialData();
        if (serialDataPending) {
            break; // Exit the loop on new serial input
        }

        bouncingBallEffect(); // Runs continuously per strip
    }
    break;

    case 9: // Fire with Audio Enhancement
      {
        #define FIRE_COOLING 150
        #define FIRE_SPARKING 80
        static uint8_t heat[NUM_VIRTUAL_STRIPS][LEDS_PER_VIRTUAL_STRIP];

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;
          }
          
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            // Cool down cells
            for (int i = 0; i < LEDS_PER_VIRTUAL_STRIP; i++) {
              heat[strip][i] = qsub8(heat[strip][i], random8(0, ((FIRE_COOLING * 5) / LEDS_PER_VIRTUAL_STRIP) + 2));
            }
            
            // Heat drifts upward
            for (int k = LEDS_PER_VIRTUAL_STRIP - 1; k >= 2; k--) {
              heat[strip][k] = (heat[strip][k - 1] + heat[strip][k - 2]) / 2;
            }
            
            // Random sparks
            if (random8() < FIRE_SPARKING) {
              int y = random8(7);
              heat[strip][y] = qadd8(heat[strip][y], random8(160, 255));
            }
            
            // Audio-based sparks (strips 1-10 mapped to bands 0-9)
            if (strip >= 1 && strip < NUM_VIRTUAL_STRIPS - 1) {
              int band = strip - 1;
              float audioLevel = bandAmplitude[band];
              
              if (audioLevel > 0.01) {
                int sparkY = random8(LEDS_PER_VIRTUAL_STRIP / 4); // Spark in bottom quarter
                uint8_t sparkIntensity = (uint8_t)(audioLevel * 255);
                heat[strip][sparkY] = qadd8(heat[strip][sparkY], sparkIntensity);
              }
            }
            
            // Map heat to LED colors with flicker
            for (int j = 0; j < LEDS_PER_VIRTUAL_STRIP; j++) {
              CRGB color = HeatColor(heat[strip][j]);
              color.nscale8_video(128 + random8(128)); // Flicker effect
              *virtualLeds[strip][j] = color;
            }
          }
          
          FastLED.show();
          delay(15);
        }
      }
      break;

    case 10: // Red Comet with Audio
      {
        #define COMET_COOLING 150
        static uint8_t heat[NUM_VIRTUAL_STRIPS][LEDS_PER_VIRTUAL_STRIP];

        for (;;) {
          processSerialData();
          if (serialDataPending) {
            break;
          }
          
          for (int strip = 0; strip < NUM_VIRTUAL_STRIPS; strip++) {
            // Cool down cells with increasing intensity as we go up
            for (int i = 0; i < LEDS_PER_VIRTUAL_STRIP; i++) {
              uint8_t coolingFactor = ((COMET_COOLING * (i + 1)) / LEDS_PER_VIRTUAL_STRIP) + 2;
              heat[strip][i] = qsub8(heat[strip][i], random8(0, coolingFactor));
            }
            
            // Audio-based comet trigger (strips 1-10 mapped to bands 0-9)
            if (strip >= 1 && strip < NUM_VIRTUAL_STRIPS - 1) {
              int band = strip - 1;
              float audioLevel = bandAmplitude[band];
              
              if (audioLevel > 0.01) {
                int cometY = random8(LEDS_PER_VIRTUAL_STRIP / 4); // Start in bottom quarter
                uint8_t cometIntensity = (uint8_t)(audioLevel * 255);
                heat[strip][cometY] = qadd8(heat[strip][cometY], cometIntensity);
              }
            }
            
            // Propagate the comet upward
            for (int k = LEDS_PER_VIRTUAL_STRIP - 1; k > 2; k--) {
              heat[strip][k] = (heat[strip][k - 1] * 3 + heat[strip][k - 2] * 2 + heat[strip][k - 3]) / 6;
            }
            
            // Map heat to flame colors with deeper red transition
            for (int j = 0; j < LEDS_PER_VIRTUAL_STRIP; j++) {
              CRGB color = HeatColor(heat[strip][j]);
              
              // Shift toward deeper red as we move up
              uint8_t redIntensity = scale8(color.r, 255 - (j * 15));
              uint8_t greenIntensity = scale8(color.g, 255 - (j * 25));
              uint8_t blueIntensity = scale8(color.b, 128 - (j * 10));
              
              *virtualLeds[strip][j] = CRGB(redIntensity, greenIntensity, blueIntensity);
            }
          }
          
          FastLED.show();
          delay(15);
        }
      }
      break;

    default:
      break;
  }
}
